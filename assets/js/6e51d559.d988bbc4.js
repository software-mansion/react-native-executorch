"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8517],{6288:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"computer-vision/useImageSegmentation","title":"useImageSegmentation","description":"Semantic image segmentation, akin to image classification, tries to assign the content of the image to one of the predefined classes. However, in case of segmentation this classification is done on a per-pixel basis, so as the result the model provides an image-sized array of scores for each of the classes. You can then use this information to detect objects on a per-pixel basis. React Native ExecuTorch offers a dedicated hook useImageSegmentation for this task.","source":"@site/docs/computer-vision/useImageSegmentation.md","sourceDirName":"computer-vision","slug":"/computer-vision/useImageSegmentation","permalink":"/react-native-executorch/docs/next/computer-vision/useImageSegmentation","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-executorch/edit/main/docs/docs/computer-vision/useImageSegmentation.md","tags":[],"version":"current","frontMatter":{"title":"useImageSegmentation"},"sidebar":"tutorialSidebar","previous":{"title":"useVerticalOCR","permalink":"/react-native-executorch/docs/next/computer-vision/useVerticalOCR"},"next":{"title":"useClassification","permalink":"/react-native-executorch/docs/next/computer-vision/useClassification"}}');var i=s(4848),r=s(8453);const o={title:"useImageSegmentation"},a=void 0,l={},d=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:3},{value:"Returns",id:"returns",level:3},{value:"Running the model",id:"running-the-model",level:2},{value:"Example",id:"example",level:2},{value:"Supported models",id:"supported-models",level:2},{value:"Benchmarks",id:"benchmarks",level:2},{value:"Model size",id:"model-size",level:3},{value:"Memory usage",id:"memory-usage",level:3},{value:"Inference time",id:"inference-time",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Semantic image segmentation, akin to image classification, tries to assign the content of the image to one of the predefined classes. However, in case of segmentation this classification is done on a per-pixel basis, so as the result the model provides an image-sized array of scores for each of the classes. You can then use this information to detect objects on a per-pixel basis. React Native ExecuTorch offers a dedicated hook ",(0,i.jsx)(n.code,{children:"useImageSegmentation"})," for this task."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["It is recommended to use models provided by us which are available at our ",(0,i.jsx)(n.a,{href:"https://huggingface.co/software-mansion/react-native-executorch-style-transfer-candy",children:"Hugging Face repository"}),", you can also use ",(0,i.jsx)(n.a,{href:"https://github.com/software-mansion/react-native-executorch/tree/main/src/constants/modelUrls.ts",children:"constants"})," shipped with our library."]})}),"\n",(0,i.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import {\n  useImageSegmentation,\n  DEEPLAB_V3_RESNET50,\n} from 'react-native-executorch';\n\nconst model = useImageSegmentation({\n  modelSource: DEEPLAB_V3_RESNET50,\n});\n\nconst imageUri = 'file::///Users/.../cute_cat.png';\n\ntry {\n  const outputDict = await model.forward(imageUri);\n} catch (error) {\n  console.error(error);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"arguments",children:"Arguments"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"modelSource"})}),"\nA string that specifies the location of the model binary. For more information, take a look at ",(0,i.jsx)(n.a,{href:"/react-native-executorch/docs/next/fundamentals/loading-models",children:"loading models"})," page."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"preventLoad?"})})," - Boolean that can prevent automatic model loading (and downloading the data if you load it for the first time) after running the hook."]}),"\n",(0,i.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Field"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"forward"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"(input: string, classesOfInterest?: DeeplabLabel[], resize?: boolean) => Promise<{[key in DeeplabLabel]?: number[]}>"})}),(0,i.jsxs)(n.td,{children:["Executes the model's forward pass, where: ",(0,i.jsx)("br",{})," * ",(0,i.jsx)(n.code,{children:"input"})," can be a fetchable resource or a Base64-encoded string. ",(0,i.jsx)("br",{})," * ",(0,i.jsx)(n.code,{children:"classesOfInterest"})," is an optional list of ",(0,i.jsx)(n.code,{children:"DeeplabLabel"}),' used to indicate additional arrays of probabilities to output (see section "Running the model"). The default is an empty list. ',(0,i.jsx)("br",{})," * ",(0,i.jsx)(n.code,{children:"resize"}),' is an optional boolean to indicate whether the output should be resized to the original image dimensions, or left in the size of the model (see section "Running the model"). The default is ',(0,i.jsx)(n.code,{children:"false"}),". ",(0,i.jsx)("br",{})," ",(0,i.jsx)("br",{})," The return is a dictionary containing: ",(0,i.jsx)("br",{})," * for the key ",(0,i.jsx)(n.code,{children:"DeeplabLabel.ARGMAX"})," an array of integers corresponding to the most probable class for each pixel ",(0,i.jsx)("br",{})," * an array of floats for each class from ",(0,i.jsx)(n.code,{children:"classesOfInterest"})," corresponding to the probabilities for this class."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"error"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)("code",{children:"string | null"})}),(0,i.jsx)(n.td,{children:"Contains the error message if the model failed to load."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"isGenerating"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsx)(n.td,{children:"Indicates whether the model is currently processing an inference."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"isReady"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsx)(n.td,{children:"Indicates whether the model has successfully loaded and is ready for inference."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"downloadProgress"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"number"})}),(0,i.jsx)(n.td,{children:"Represents the download progress as a value between 0 and 1."})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"running-the-model",children:"Running the model"}),"\n",(0,i.jsxs)(n.p,{children:["To run the model, you can use the ",(0,i.jsx)(n.code,{children:"forward"})," method. It accepts three arguments: a required image, an optional list of classes, and an optional flag whether to resize the output to the original dimensions."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The image can be a remote URL, a local file URI, or a base64-encoded image."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"classesOfInterest"})," list contains classes for which to output the full results. By default the list is empty, and only the most probable classes are returned (essentially an arg max for each pixel). Look at ",(0,i.jsx)(n.a,{href:"http://github.com/software-mansion/react-native-executorch/blob/main/src/types/image_segmentation.ts",children:(0,i.jsx)(n.code,{children:"DeeplabLabel"})})," enum for possible classes."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"resize"})," flag says whether the output will be rescaled back to the size of the image you put in. The default is ",(0,i.jsx)(n.code,{children:"false"}),". The model runs inference on a scaled (probably smaller) version of your image (224x224 for ",(0,i.jsx)(n.code,{children:"DEEPLAB_V3_RESNET50"}),"). If you choose to resize, the output will be ",(0,i.jsx)(n.code,{children:"number[]"})," of size ",(0,i.jsx)(n.code,{children:"width * height"})," of your original image."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["Setting ",(0,i.jsx)(n.code,{children:"resize"})," to true will make ",(0,i.jsx)(n.code,{children:"forward"})," slower."]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"forward"})," returns a promise which can resolve either to an error or a dictionary containing number arrays with size depending on ",(0,i.jsx)(n.code,{children:"resize"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For the key ",(0,i.jsx)(n.code,{children:"DeeplabLabel.ARGMAX"})," the array contains for each pixel an integer corresponding to the class with the highest probability."]}),"\n",(0,i.jsxs)(n.li,{children:["For every other key from ",(0,i.jsx)(n.code,{children:"DeeplabLabel"}),", if the label was included in ",(0,i.jsx)(n.code,{children:"classesOfInterest"})," the dictionary will contain an array of floats corresponding to the probability of this class for every pixel."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function App(){\n  const model = useImageSegmentation(\n    modelSource: DEEPLAB_V3_RESNET50,\n  );\n\n  ...\n  const imageUri = 'file::///Users/.../cute_cat.png';\n\n  try{\n      const outputDict = await model.forward(imageUri, [DeeplabLabel.CAT], true);\n  }catch(error){\n      console.error(error);\n  }\n  ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"supported-models",children:"Supported models"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Model"}),(0,i.jsx)(n.th,{children:"Number of classes"}),(0,i.jsx)(n.th,{children:"Class list"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://pytorch.org/vision/0.20/models/generated/torchvision.models.segmentation.deeplabv3_resnet50.html",children:"deeplabv3_resnet50"})}),(0,i.jsx)(n.td,{children:"21"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"http://github.com/software-mansion/react-native-executorch/blob/main/src/types/image_segmentation.ts",children:"DeeplabLabel"})})]})})]}),"\n",(0,i.jsx)(n.h2,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,i.jsx)(n.h3,{id:"model-size",children:"Model size"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Model"}),(0,i.jsx)(n.th,{children:"XNNPACK [MB]"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEELABV3_RESNET50"}),(0,i.jsx)(n.td,{children:"168"})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"memory-usage",children:"Memory usage"}),"\n",(0,i.jsx)(n.admonition,{title:"warning",type:"warning",children:(0,i.jsx)(n.p,{children:"Data presented in the following sections is based on inference with non-resized output. When resize is enabled, expect higher memory usage and inference time with higher resolutions."})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Model"}),(0,i.jsx)(n.th,{children:"Android (XNNPACK) [MB]"}),(0,i.jsx)(n.th,{children:"iOS (XNNPACK) [MB]"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEELABV3_RESNET50"}),(0,i.jsx)(n.td,{children:"930"}),(0,i.jsx)(n.td,{children:"660"})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"inference-time",children:"Inference time"}),"\n",(0,i.jsx)(n.admonition,{title:"warning",type:"warning",children:(0,i.jsx)(n.p,{children:"Times presented in the tables are measured as consecutive runs of the model. Initial run times may be up to 2x longer due to model loading and initialization."})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Model"}),(0,i.jsx)(n.th,{children:"iPhone 16 Pro (Core ML) [ms]"}),(0,i.jsx)(n.th,{children:"iPhone 14 Pro Max (Core ML) [ms]"}),(0,i.jsx)(n.th,{children:"Samsung Galaxy S24 (XNNPACK) [ms]"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEELABV3_RESNET50"}),(0,i.jsx)(n.td,{children:"1000"}),(0,i.jsx)(n.td,{children:"670"}),(0,i.jsx)(n.td,{children:"700"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);