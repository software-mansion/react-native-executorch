"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[468],{5680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>m});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,m=c["".concat(l,".").concat(u)]||c[u]||g[u]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},412:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(8168),r=(n(6540),n(5680));const o={title:"useSpeechToText",sidebar_position:1,keywords:["speech to text","stt","voice recognition","transcription","whisper","moonshine","react native","executorch","ai","machine learning","on-device","mobile ai"],description:"Learn how to use speech-to-text models in your React Native applications with React Native ExecuTorch's useSpeechToText hook."},i=void 0,s={unversionedId:"speech-to-text/useSpeechToText",id:"speech-to-text/useSpeechToText",title:"useSpeechToText",description:"Learn how to use speech-to-text models in your React Native applications with React Native ExecuTorch's useSpeechToText hook.",source:"@site/docs/speech-to-text/useSpeechToText.md",sourceDirName:"speech-to-text",slug:"/speech-to-text/useSpeechToText",permalink:"/react-native-executorch/docs/speech-to-text/useSpeechToText",draft:!1,editUrl:"https://github.com/software-mansion/react-native-executorch/edit/main/docs/docs/speech-to-text/useSpeechToText.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"useSpeechToText",sidebar_position:1,keywords:["speech to text","stt","voice recognition","transcription","whisper","moonshine","react native","executorch","ai","machine learning","on-device","mobile ai"],description:"Learn how to use speech-to-text models in your React Native applications with React Native ExecuTorch's useSpeechToText hook."},sidebar:"tutorialSidebar",previous:{title:"Speech To Text",permalink:"/react-native-executorch/docs/category/speech-to-text"},next:{title:"Computer Vision",permalink:"/react-native-executorch/docs/category/computer-vision"}},l={},p=[{value:"Reference",id:"reference",level:2},{value:"Streaming",id:"streaming",level:3},{value:"Arguments",id:"arguments",level:3},{value:"Returns",id:"returns",level:3},{value:"Running the model",id:"running-the-model",level:2},{value:"Example",id:"example",level:2},{value:"Supported models",id:"supported-models",level:2},{value:"Benchmarks",id:"benchmarks",level:2},{value:"Model size",id:"model-size",level:3},{value:"Memory usage",id:"memory-usage",level:3}],d={toc:p},c="wrapper";function g(e){let{components:t,...n}=e;return(0,r.yg)(c,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"With the latest ",(0,r.yg)("inlineCode",{parentName:"p"},"v0.3.0")," release we introduce a new hook - ",(0,r.yg)("inlineCode",{parentName:"p"},"useSpeechToText"),". Speech to text is a task that allows to transform spoken language to written text. It is commonly used to implement features such as transcription or voice assistants. As of now, ",(0,r.yg)("a",{parentName:"p",href:"#supported-models"},"all supported STT models")," run on the XNNPACK backend."),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Currently, we do not support direct microphone input streaming to the model. Instead, in v0.3.0, we provide a way to transcribe an audio file.")),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"It is recommended to use models provided by us, which are available at our ",(0,r.yg)("a",{parentName:"p",href:"https://huggingface.co/software-mansion/react-native-executorch-moonshine-tiny"},"Hugging Face repository"),". You can also use ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/software-mansion/react-native-executorch/tree/main/src/constants/modelUrls.ts"},"constants")," shipped with our library")),(0,r.yg)("h2",{id:"reference"},"Reference"),(0,r.yg)("p",null,"You can obtain waveform from audio in any way most suitable to you, however in the snippet below we utilize ",(0,r.yg)("inlineCode",{parentName:"p"},"react-native-audio-api")," library to process a mp3 file."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"import { useSpeechToText } from 'react-native-executorch';\nimport { AudioContext } from 'react-native-audio-api';\nimport * as FileSystem from 'expo-file-system';\n\nconst { transcribe, error } = useSpeechToText({\n  modelName: 'moonshine',\n});\n\nconst loadAudio = async (url: string) => {\n  const audioContext = new AudioContext({ sampleRate: 16e3 });\n  const audioBuffer = await FileSystem.downloadAsync(\n    url,\n    FileSystem.documentDirectory + '_tmp_transcribe_audio.mp3'\n  ).then(({ uri }) => {\n    return audioContext.decodeAudioDataSource(uri);\n  });\n  return audioBuffer?.getChannelData(0);\n};\n\nconst audioUrl = ...; // URL with audio to transcribe\nconst waveform = await loadAudio(audioUrl);\nconst transcription = await transcribe(waveform);\nif (error) {\n  console.log(error);\n} else {\n  console.log(transcription);\n}\n")),(0,r.yg)("h3",{id:"streaming"},"Streaming"),(0,r.yg)("p",null,"Given that STT models can process audio no longer than 30 seconds, there is a need to chunk the input audio. Chunking audio may result in cutting speech mid-sentence, which might be hard to understand for the model. To make it work, we employed an algorithm (adapted for mobile devices from ",(0,r.yg)("a",{parentName:"p",href:"https://aclanthology.org/2023.ijcnlp-demo.3.pdf"},"whisper-streaming"),") that uses overlapping audio chunks. This might introduce some overhead, but allows for processing audio inputs of arbitrary length."),(0,r.yg)("h3",{id:"arguments"},"Arguments"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"modelName")),"\nA literal of ",(0,r.yg)("inlineCode",{parentName:"p"},'"moonshine" | "whisper"')," which serves as an identifier for which model should be used."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"encoderSource?")),"\nA string that specifies the location of a .pte file for the encoder. For further information on passing model sources, check out ",(0,r.yg)("a",{parentName:"p",href:"https://docs.swmansion.com/react-native-executorch/docs/fundamentals/loading-models"},"Loading Models"),". Defaults to ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/software-mansion/react-native-executorch/blob/main/src/constants/modelUrls.ts"},"constants")," for given model."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"decoderSource?")),"\nAnalogous to the encoderSource, this takes in a string which is a source for the decoder part of the model. Defaults to ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/software-mansion/react-native-executorch/blob/main/src/constants/modelUrls.ts"},"constants")," for given model."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"tokenizerSource?")),"\nA string that specifies the location to the tokenizer for the model. This works just as the encoder and decoder do. Defaults to ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/software-mansion/react-native-executorch/blob/main/src/constants/modelUrls.ts"},"constants")," for given model."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"overlapSeconds?")),"\nSpecifies the length of overlap between consecutive audio chunks (expressed in seconds). Overrides ",(0,r.yg)("inlineCode",{parentName:"p"},"streamingConfig")," argument."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"windowSize?")),"\nSpecifies the size of each audio chunk (expressed in seconds). Overrides ",(0,r.yg)("inlineCode",{parentName:"p"},"streamingConfig")," argument."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"streamingConfig?")),"\nSpecifies config for both ",(0,r.yg)("inlineCode",{parentName:"p"},"overlapSeconds")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"windowSize")," values. Three options are available: ",(0,r.yg)("inlineCode",{parentName:"p"},"fast"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"balanced")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"quality"),". We discourage using ",(0,r.yg)("inlineCode",{parentName:"p"},"fast")," config with ",(0,r.yg)("inlineCode",{parentName:"p"},"Whisper")," model which while has the lowest latency to first token has the slowest overall speed."),(0,r.yg)("h3",{id:"returns"},"Returns"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Field"),(0,r.yg)("th",{parentName:"tr",align:null},"Type"),(0,r.yg)("th",{parentName:"tr",align:null},"Description"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"transcribe")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"(input: number[]) => Promise<string>")),(0,r.yg)("td",{parentName:"tr",align:null},"Starts a transcription process for a given input array, which should be a waveform at 16kHz. Resolves a promise with the output transcription when the model is finished.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"error")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("code",null,"Error ","|"," undefined")),(0,r.yg)("td",{parentName:"tr",align:null},"Contains the error message if the model failed to load.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"sequence")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("code",null,"string")),(0,r.yg)("td",{parentName:"tr",align:null},"This property is updated with each generated token. If you're looking to obtain tokens as they're generated, you should use this property.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"isGenerating")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"boolean")),(0,r.yg)("td",{parentName:"tr",align:null},"Indicates whether the model is currently processing an inference.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"isReady")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"boolean")),(0,r.yg)("td",{parentName:"tr",align:null},"Indicates whether the model has successfully loaded and is ready for inference.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"configureStreaming")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("code",null,"(overlapSeconds?: number, windowSize?: number, streamingConfig?: 'fast' ","|"," 'balanced' ","|"," 'quality')")),(0,r.yg)("td",{parentName:"tr",align:null},"Configures options for the streaming algorithm: ",(0,r.yg)("ul",null,(0,r.yg)("li",null,(0,r.yg)("inlineCode",{parentName:"td"},"overlapSeconds")," determines how much adjacent audio chunks overlap (increasing it slows down transcription, decreases probability of weird wording at the chunks intersection, setting it larger than 3 seconds generally is discouraged), "),(0,r.yg)("li",null,(0,r.yg)("inlineCode",{parentName:"td"},"windowSize")," describes size of the audio chunks (increasing it speeds up the end to end transcription time, but increases latency for the first token to be returned),"),(0,r.yg)("li",null," ",(0,r.yg)("inlineCode",{parentName:"td"},"streamingConfig")," predefined configs for ",(0,r.yg)("inlineCode",{parentName:"td"},"windowSize")," and ",(0,r.yg)("inlineCode",{parentName:"td"},"overlapSeconds")," values."))," Keep ",(0,r.yg)("inlineCode",{parentName:"td"},"windowSize + 2 * overlapSeconds <= 30"),".")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"downloadProgress")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"number")),(0,r.yg)("td",{parentName:"tr",align:null},"Tracks the progress of the model download process.")))),(0,r.yg)("h2",{id:"running-the-model"},"Running the model"),(0,r.yg)("p",null,"Before running the model's ",(0,r.yg)("inlineCode",{parentName:"p"},"transcribe")," method be sure to obtain waveform of the audio You wish to transcribe. You need to obtain the waveform from audio on your own (remember to use sampling rate of 16kHz!), in the snippet above we provide an example how you can do that. In the latter case just pass the obtained waveform as argument to the ",(0,r.yg)("inlineCode",{parentName:"p"},"transcribe")," method which returns a promise resolving to the generated tokens when successful. If the model fails during inference the ",(0,r.yg)("inlineCode",{parentName:"p"},"error")," property contains details of the error. If you want to obtain tokens in a streaming fashion, you can also use the sequence property, which is updated with each generated token, similar to the ",(0,r.yg)("a",{parentName:"p",href:"/react-native-executorch/docs/llms/useLLM"},"useLLM")," hook."),(0,r.yg)("h2",{id:"example"},"Example"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-typescript"},"import { Button, Text } from 'react-native';\nimport { useSpeechToText } from 'react-native-executorch';\n\nfunction App() {\n  const { loadAudio, transcribe, sequence, error } = useSpeechToText({\n    modelName: 'whisper',\n  });\n\n  const audioUrl = ...; // URL with audio to transcribe\n\n  return (\n    <View>\n      <Button\n        onPress={async () => {\n          await loadAudio(audioUrl);\n          await transcribe();\n        }\n        title=\"Transcribe\"\n      />\n      <Text>{error ? error : sequence}</Text>\n    </View>\n  );\n}\n")),(0,r.yg)("h2",{id:"supported-models"},"Supported models"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Model"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Language"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://huggingface.co/openai/whisper-tiny.en"},"Whisper tiny.en")),(0,r.yg)("td",{parentName:"tr",align:"center"},"English")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://huggingface.co/UsefulSensors/moonshine-tiny"},"Moonshine tiny")),(0,r.yg)("td",{parentName:"tr",align:"center"},"English")))),(0,r.yg)("h2",{id:"benchmarks"},"Benchmarks"),(0,r.yg)("h3",{id:"model-size"},"Model size"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Model"),(0,r.yg)("th",{parentName:"tr",align:"center"},"XNNPACK ","[MB]"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"WHISPER_TINY"),(0,r.yg)("td",{parentName:"tr",align:"center"},"231.0")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"MOONSHINE_TINY"),(0,r.yg)("td",{parentName:"tr",align:"center"},"148.9")))),(0,r.yg)("h3",{id:"memory-usage"},"Memory usage"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Model"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Android (XNNPACK) ","[MB]"),(0,r.yg)("th",{parentName:"tr",align:"center"},"iOS (XNNPACK) ","[MB]"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"WHISPER_TINY"),(0,r.yg)("td",{parentName:"tr",align:"center"},"900"),(0,r.yg)("td",{parentName:"tr",align:"center"},"600")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"MOONSHINE_TINY"),(0,r.yg)("td",{parentName:"tr",align:"center"},"650"),(0,r.yg)("td",{parentName:"tr",align:"center"},"560")))))}g.isMDXComponent=!0}}]);