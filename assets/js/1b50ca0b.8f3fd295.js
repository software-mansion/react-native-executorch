"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[703],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=r.createContext({}),s=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=o,g=u["".concat(d,".").concat(m)]||u[m]||c[m]||a;return n?r.createElement(g,i(i({ref:t},p),{},{components:n})):r.createElement(g,i({ref:t},p))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[u]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},984:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var r=n(8168),o=(n(6540),n(5680));const a={title:"ExecuTorchModule",sidebar_position:2},i=void 0,l={unversionedId:"hookless-api/ExecutorchModule",id:"hookless-api/ExecutorchModule",title:"ExecuTorchModule",description:"Hookless implementation of the useExecutorchModule hook.",source:"@site/docs/hookless-api/ExecutorchModule.md",sourceDirName:"hookless-api",slug:"/hookless-api/ExecutorchModule",permalink:"/react-native-executorch/docs/hookless-api/ExecutorchModule",draft:!1,editUrl:"https://github.com/software-mansion/react-native-executorch/edit/main/docs/docs/hookless-api/ExecutorchModule.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"ExecuTorchModule",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"ClassificationModule",permalink:"/react-native-executorch/docs/hookless-api/ClassificationModule"},next:{title:"LLMModule",permalink:"/react-native-executorch/docs/hookless-api/LLMModule"}},d={},s=[{value:"Reference",id:"reference",level:2},{value:"Methods",id:"methods",level:3},{value:"Loading the model",id:"loading-the-model",level:2},{value:"Running the model",id:"running-the-model",level:2},{value:"Loading methods",id:"loading-methods",level:2},{value:"Loading forward",id:"loading-forward",level:2}],p={toc:s},u="wrapper";function c(e){let{components:t,...n}=e;return(0,o.yg)(u,(0,r.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Hookless implementation of the ",(0,o.yg)("a",{parentName:"p",href:"/react-native-executorch/docs/module-api/executorch-bindings"},"useExecutorchModule")," hook."),(0,o.yg)("h2",{id:"reference"},"Reference"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"import {\n  ExecutorchModule,\n  STYLE_TRANSFER_CANDY,\n} from 'react-native-executorch';\n\n// Creating the input array\nconst shape = [1, 3, 640, 640];\nconst input = new Float32Array(1 * 3 * 640 * 640);\n\n// Loading the model\nawait ExecutorchModule.load(STYLE_TRANSFER_CANDY);\n\n// Running the model\nconst output = await ExecutorchModule.forward(input, shape);\n")),(0,o.yg)("h3",{id:"methods"},"Methods"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"Method"),(0,o.yg)("th",{parentName:"tr",align:null},"Type"),(0,o.yg)("th",{parentName:"tr",align:null},"Description"))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"load")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"(modelSource: ResourceSource): Promise<void>")),(0,o.yg)("td",{parentName:"tr",align:null},"Loads the model, where ",(0,o.yg)("inlineCode",{parentName:"td"},"modelSource")," is a string that specifies the location of the model binary.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"forward")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"(input: ETInput, shape: number[]): Promise<number[]>")),(0,o.yg)("td",{parentName:"tr",align:null},"Executes the model's forward pass, where ",(0,o.yg)("inlineCode",{parentName:"td"},"input")," is a JavaScript typed array and ",(0,o.yg)("inlineCode",{parentName:"td"},"shape")," is an array of integers representing input Tensor shape. The output is a Tensor - raw result of inference.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"loadMethod")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"(methodName: string): Promise<void>")),(0,o.yg)("td",{parentName:"tr",align:null},"Loads resources specific to ",(0,o.yg)("inlineCode",{parentName:"td"},"methodName")," into memory before execution.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"loadForward")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"(): Promise<void>")),(0,o.yg)("td",{parentName:"tr",align:null},"Loads resources specific to ",(0,o.yg)("inlineCode",{parentName:"td"},"forward")," method into memory before execution. Uses ",(0,o.yg)("inlineCode",{parentName:"td"},"loadMethod")," under the hood.")),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"onDownloadProgress")),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("inlineCode",{parentName:"td"},"(callback: (downloadProgress: number) => void): any")),(0,o.yg)("td",{parentName:"tr",align:null},"Subscribe to the download progress event.")))),(0,o.yg)("details",null,(0,o.yg)("summary",null,"Type definitions"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-typescript"},"type ResourceSource = string | number;\n\nexport type ETInput =\n  | Int8Array\n  | Int32Array\n  | BigInt64Array\n  | Float32Array\n  | Float64Array;\n"))),(0,o.yg)("h2",{id:"loading-the-model"},"Loading the model"),(0,o.yg)("p",null,"To load the model, use the ",(0,o.yg)("inlineCode",{parentName:"p"},"load")," method. It accepts the ",(0,o.yg)("inlineCode",{parentName:"p"},"modelSource")," which is a string that specifies the location of the model binary. For more information, take a look at ",(0,o.yg)("a",{parentName:"p",href:"/react-native-executorch/docs/fundamentals/loading-models"},"loading models")," page. This method returns a promise, which can resolve to an error or void."),(0,o.yg)("h2",{id:"running-the-model"},"Running the model"),(0,o.yg)("p",null,"To run the model use the ",(0,o.yg)("inlineCode",{parentName:"p"},"forward")," method. It accepts two arguments: ",(0,o.yg)("inlineCode",{parentName:"p"},"input")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"shape"),". The ",(0,o.yg)("inlineCode",{parentName:"p"},"input")," is a JavaScript typed array, and ",(0,o.yg)("inlineCode",{parentName:"p"},"shape")," is an array of integers representing the input tensor shape. There's no need to explicitly define the input type, as it will automatically be inferred from the typed array you pass to forward method. Outputs from the model, such as classification probabilities, are returned in raw format."),(0,o.yg)("h2",{id:"loading-methods"},"Loading methods"),(0,o.yg)("p",null,"Loads resources specific to methodName into memory before execution."),(0,o.yg)("h2",{id:"loading-forward"},"Loading forward"),(0,o.yg)("p",null,"Loads resources specific to ",(0,o.yg)("inlineCode",{parentName:"p"},"forward")," method into memory before execution. Uses loadMethod under the hood."),(0,o.yg)("admonition",{type:"info"},(0,o.yg)("p",{parentName:"admonition"},"This code assumes that you have handled preprocessing of the input image (scaling, normalization) and postprocessing of the output (interpreting the raw output data) according to the model's requirements. Make sure to adjust these parts depending on your specific data and model outputs.")))}c.isMDXComponent=!0}}]);