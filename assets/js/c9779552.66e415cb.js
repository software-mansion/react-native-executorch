"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2642],{3941:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"hookless-api/SpeechToTextModule","title":"SpeechToTextModule","description":"Hookless implementation of the useSpeechToText hook.","source":"@site/versioned_docs/version-0.3.x/hookless-api/SpeechToTextModule.md","sourceDirName":"hookless-api","slug":"/hookless-api/SpeechToTextModule","permalink":"/react-native-executorch/docs/0.3.x/hookless-api/SpeechToTextModule","draft":false,"unlisted":false,"editUrl":"https://github.com/software-mansion/react-native-executorch/edit/main/docs/versioned_docs/version-0.3.x/hookless-api/SpeechToTextModule.md","tags":[],"version":"0.3.x","sidebarPosition":6,"frontMatter":{"title":"SpeechToTextModule","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"OCRModule","permalink":"/react-native-executorch/docs/0.3.x/hookless-api/OCRModule"},"next":{"title":"VerticalOCRModule","permalink":"/react-native-executorch/docs/0.3.x/hookless-api/VerticalOCRModule"}}');var r=n(4848),i=n(8453);const s={title:"SpeechToTextModule",sidebar_position:6},d=void 0,c={},a=[{value:"Reference",id:"reference",level:2},{value:"Methods",id:"methods",level:3},{value:"Loading the model",id:"loading-the-model",level:2},{value:"Running the model",id:"running-the-model",level:2},{value:"Obtaining the input",id:"obtaining-the-input",level:2}];function l(e){const o={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components},{Details:n}=o;return n||function(e,o){throw new Error("Expected "+(o?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(o.p,{children:["Hookless implementation of the ",(0,r.jsx)(o.a,{href:"/react-native-executorch/docs/0.3.x/speech-to-text/useSpeechToText",children:"useSpeechToText"})," hook."]}),"\n",(0,r.jsx)(o.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-typescript",children:"import { useSpeechToText } from 'react-native-executorch';\nimport { AudioContext } from 'react-native-audio-api';\nimport * as FileSystem from 'expo-file-system';\n\nconst loadAudio = async (url: string) => {\n  const audioContext = new AudioContext({ sampleRate: 16e3 });\n  const audioBuffer = await FileSystem.downloadAsync(\n    url,\n    FileSystem.documentDirectory + '_tmp_transcribe_audio.mp3'\n  ).then(({ uri }) => {\n    return audioContext.decodeAudioDataSource(uri);\n  });\n  return Array.from(audioBuffer?.getChannelData(0));\n};\n\nconst audioUrl = ...; // URL with audio to transcribe\n\n// Loading the model\nconst onSequenceUpdate = (sequence) => {\n    console.log(sequence);\n};\nawait SpeechToTextModule.load('moonshine', onSequenceUpdate);\n\n// Loading the audio and running the model\nconst waveform = await loadAudio(audioUrl);\nconst transcribedText = await SpeechToTextModule.transcribe(waveform);\n"})}),"\n",(0,r.jsx)(o.h3,{id:"methods",children:"Methods"}),"\n",(0,r.jsxs)(o.table,{children:[(0,r.jsx)(o.thead,{children:(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.th,{children:"Method"}),(0,r.jsx)(o.th,{children:"Type"}),(0,r.jsx)(o.th,{children:"Description"})]})}),(0,r.jsxs)(o.tbody,{children:[(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"load"})}),(0,r.jsx)(o.td,{children:(0,r.jsx)("code",{children:"(modelName: 'whisper' &#124 'moonshine, transcribeCallback?: (sequence: string) => void, modelDownloadProgressCallback?: (downloadProgress: number) => void, encoderSource?: ResourceSource, decoderSource?: ResourceSource, tokenizerSource?: ResourceSource)"})}),(0,r.jsxs)(o.td,{children:["Loads the model specified with ",(0,r.jsx)(o.code,{children:"modelName"}),", where ",(0,r.jsx)(o.code,{children:"encoderSource"}),", ",(0,r.jsx)(o.code,{children:"decoderSource"}),", ",(0,r.jsx)(o.code,{children:"tokenizerSource"})," are strings specifying the location of the binaries for the models. ",(0,r.jsx)(o.code,{children:"modelDownloadProgressCallback"})," allows you to monitor the current progress of the model download, while ",(0,r.jsx)(o.code,{children:"transcribeCallback"})," is invoked with each generated token"]})]}),(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"transcribe"})}),(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"(waveform: number[]): Promise<string>"})}),(0,r.jsx)(o.td,{children:"Starts a transcription process for a given input array, which should be a waveform at 16kHz. Resolves a promise with the output transcription when the model is finished."})]}),(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"encode"})}),(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"(waveform: number[]) => Promise<number[]>"})}),(0,r.jsx)(o.td,{children:"Runs the encoding part of the model. Returns a float array representing the output of the encoder."})]}),(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"decode"})}),(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"(tokens: number[], encodings?: number[]) => Promise<number[]>"})}),(0,r.jsxs)(o.td,{children:["Runs the decoder of the model. Returns a single token representing a next token in the output sequence. If ",(0,r.jsx)(o.code,{children:"encodings"})," are provided then they are used for decoding process, if not then the cached encodings from most recent ",(0,r.jsx)(o.code,{children:"encode"})," call are used. The cached option is much faster due to very large overhead for communication between native and react layers."]})]}),(0,r.jsxs)(o.tr,{children:[(0,r.jsx)(o.td,{children:(0,r.jsx)(o.code,{children:"configureStreaming"})}),(0,r.jsx)(o.td,{children:(0,r.jsx)("code",{children:"(overlapSeconds?: number, windowSize?: number, streamingConfig?: 'fast' | 'balanced' | 'quality') => void"})}),(0,r.jsxs)(o.td,{children:["Configures options for the streaming algorithm: ",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)(o.code,{children:"overlapSeconds"})," determines how much adjacent audio chunks overlap (increasing it slows down transcription, decreases probability of weird wording at the chunks intersection, setting it larger than 3 seconds generally is discouraged), "]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(o.code,{children:"windowSize"})," describes size of the audio chunks (increasing it speeds up the end to end transcription time, but increases latency for the first token to be returned),"]}),(0,r.jsxs)("li",{children:[" ",(0,r.jsx)(o.code,{children:"streamingConfig"})," predefined configs for ",(0,r.jsx)(o.code,{children:"windowSize"})," and ",(0,r.jsx)(o.code,{children:"overlapSeconds"})," values."]})]})," Keep ",(0,r.jsx)(o.code,{children:"windowSize + 2 * overlapSeconds <= 30"}),"."]})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Type definitions"}),(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-typescript",children:"type ResourceSource = string | number;\n"})})]}),"\n",(0,r.jsx)(o.h2,{id:"loading-the-model",children:"Loading the model"}),"\n",(0,r.jsxs)(o.p,{children:["To load the model, use the ",(0,r.jsx)(o.code,{children:"load"})," method. The required argument is ",(0,r.jsx)(o.code,{children:"modelName"}),", which serves as an identifier for which model to use. It also accepts accepts optional arguments such as ",(0,r.jsx)(o.code,{children:"encoderSource"}),", ",(0,r.jsx)(o.code,{children:"decoderSource"}),", ",(0,r.jsx)(o.code,{children:"tokenizerSource"})," which are strings that specify the location of the binaries for the model. For more information, take a look at ",(0,r.jsx)(o.a,{href:"/react-native-executorch/docs/0.3.x/fundamentals/loading-models",children:"loading models"})," page. This method returns a promise, which can resolve to an error or void."]}),"\n",(0,r.jsx)(o.h2,{id:"running-the-model",children:"Running the model"}),"\n",(0,r.jsxs)(o.p,{children:["To run the model, you can use the ",(0,r.jsx)(o.code,{children:"transcribe"})," method. It accepts one argument, which is an array of numbers representing a waveform at 16kHz sampling rate. The method returns a promise, which can resolve either to an error or a string containing the output text."]}),"\n",(0,r.jsx)(o.h2,{id:"obtaining-the-input",children:"Obtaining the input"}),"\n",(0,r.jsxs)(o.p,{children:["You need to parse audio to waveform in 16kHz, you can do that in any way most suitable to you. In the snippet at the top of the page we provide an example using ",(0,r.jsx)(o.code,{children:"react-native-audio-api"}),". Once you have the waveform simply pass it as the only argument to ",(0,r.jsx)(o.code,{children:"transcribe"})," method."]})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>s,x:()=>d});var t=n(6540);const r={},i=t.createContext(r);function s(e){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function d(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);